elem(x,[=x|xs]) -> 'tt,
elem(x,[z|xs]) -> elem(x,xs),
elem(x,y) -> 'ff

alphaNum -> [|0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz|]
isAlphaNum(c) -> elem(c,alphaNum)

whitespace -> [| 
 |]
isSpace(c) -> elem(c,whitespace)

case(x,f) -> f(x)

state(,get set):
state(s,x) -> [x,s],
state(s,{'get() -> k}) -> state(s,k(s)),
state(s,{'set(s1) -> k}) -> state(s1,k([]))

catch(abort,):
catch(x,f) -> x,
catch({'abort() -> k},f) -> f()

qes(x,y) -> x

protect(f) -> {|s -> 'get()
		t([x,s]) -> 'set(s); x
	       |}t(state(s,f()))

eat() -> case('get(),{([c|s]) -> 'set(s); c})

if('tt,f,g) -> f(),
if('ff,f,g) -> g()

like(p,x) -> if(p(x),{x},{'abort()})

many(f) -> catch([protect(f)|many(f)],{[]})

some(f) -> [protect(f)|many(f)]

collapse([]) -> [||],
collapse([x|y]) -> [|`x``collapse(y)`|]

ident() -> collapse(some({like(isAlphaNum,eat())}))

gap() -> many({like(isSpace,eat())}); []

choice([]) -> 'abort(),
choice([f|fs]) -> catch(protect(f),{choice(fs)})

eq(x,=x) -> 'tt,
eq(x,y) -> 'ff

must('tt) -> [],
must('ff) -> 'abort()

gimme(c) -> must(eq(eat(),c))

map(f,[x|xs]) -> [f(x)|map(f,xs)],
map(f,[]) -> []

punc(cs) -> map(gimme,cs); gap()

exp() -> choice(
  [{app(['var,ident()])}
  ,{app(['atom,gimme([|'|]);ident()])}
  ,{punc([|[|]); lisp(exp)}
  ])

lisp(f) -> {|
  nil() -> gimme([|]|]);['atom,[||]]
  cell() -> ['cons,f(),cdr()]
  cdr() -> gap();choice(
    [nil
    ,{punc([|\||]); qes(f(),gap();gimme([|]|]))}
    ,{punc([|,|]); cell()}
    ])
  |}choice([nil,cell])

csep(f,t) -> {|
  end() -> map(gimme,t); []
  more() -> gap(); choice(
      [{[punc([|,|]); f()|more()]}
      ,end
      ])
  |}choice(
  [{[f()|more()]}
  ,end
  ])
  
app(f) -> choice(
  [{punc([|(|]); app(['app,f|csep(exp,[|)|])])}
  ,{punc([|;|]); app(['seq,f,exp()])}
  ,{f}
  ])
